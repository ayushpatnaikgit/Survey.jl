%% The paper limit is 2 pages. Try pushing some things to the footnote, as space is reserved for it. Don't change the template. 

\documentclass{juliacon}
\setcounter{page}{1}

\usepackage{amsmath}

\begin{document}

\input{header}

\maketitle

\begin{abstract}

In the domain of survey data analysis, a persistent challenge involves accurately estimating variances while accounting for complex survey designs. The Survey.jl package implements 

\end{abstract}

\section{Introduction}

Survey dataset are growing. There is a need for a faster framwork for resampling methods. 

%% Short summary of the paper

\section{Related work}

%% Check links. It's from here: https://www.hcp.med.harvard.edu/statistics/survey-soft/#Packages

There are many packages for Survey analysis. A list and summary of the packages is provided by Section on Survey Research Methods, American Statistical Association \cite{SummarySurveyAnalysis}. 

\href{https://www.hcp.med.harvard.edu/statistics/survey-soft/am.html}{AM Software}, 
\href{https://www.hcp.med.harvard.edu/statistics/survey-soft/bascula.html}{Bascula}, 
\href{https://www.hcp.med.harvard.edu/statistics/survey-soft/cenvar.html}{CENVAR}, 
\href{https://www.hcp.med.harvard.edu/statistics/survey-soft/clusters.html}{CLUSTERS},  
\href{https://www.cdc.gov/epiinfo/index.html}{Epi Info},  
\href{https://www.statcan.gc.ca/eng/survey/methodology/Generalized_Estimation_System-eng.htm}{Generalized Estimation System (GES)},  
\href{https://isr.umich.edu/}{IVEware},  
\href{https://catalog.iastate.edu/azcourses/stat/}{PCCARP},  
\href{https://cran.r-project.org/package=survey}{R survey package}, 
\href{https://www.sas.com/en_us/home.html}{SAS/STAT},  
\href{https://www.ibm.com/products/spss-statistics}{SPSS Complex Samples},  
\href{https://www.stata.com/}{Stata},  
\href{https://sudaanorder.rti.org/}{SUDAAN},  
\href{https://www.census.gov/data/software/vplx.html}{VPLX},  
\href{https://www.westat.com/wesvar/}{WesVar}

The survey package in R by Thomas Lumely \cite{lumley2004analysis} is the most wide used open-source alternatives. 



\section{Survey design}

The data, along with the sampling design, can be used to make a \verb|SurveyDesign| object.
\\
The parameters are:
 
\begin{itemize}
    \item \verb|data::DataFrame|, data in the form of a \verb|DataFrame|
    \item \verb|clusters::Symbol|, name of the column containing clusters.
    \item \verb|strata::Symbol|, name of the column containing the strata.
    \item \verb|weights::Symbol|, name of the column containing the weights.
    \item \verb|popsize::Symbol|, name of the column containing the population size. 
\end{itemize}

%% Perhaps, have only 1 example, NHANES. Tell that there are others in the documentation. No need to repeast the documentation here. 

% \subsection{Example: Simple random sample}

% \begin{lstlisting}
% julia> srs = load_data("apisrs");

% julia> SurveyDesign(srs; weights=:pw)
% SurveyDesign:
% data: 200 x 45 DataFrame
% strata: none
% cluster: none
% popsize: [6194.0, 6194.0, 6194.0 ...  6194.0]
% sampsize: [200, 200, 200 ...  200]
% weights: [30.97, 30.97, 30.97  ...  30.97]
% allprobs: [0.0323, 0.0323, 0.0323  ...  0.0323]
% \end{lstlisting}

% \subsection{Example: Stratified sample}

% \begin{lstlisting}
% julia> strat = load_data("apistrat");

% julia> dstrat = SurveyDesign(strat; weights = :pw,
%                 strata = :stype)
% SurveyDesign:
% data: 200 x 44 DataFrame
% strata: stype
%     [E, E, E  ...  H]
% cluster: none
% popsize: [4420.9999, 4420.9999, 4420.9999  ...  755.0]
% sampsize: [100, 100, 100  ...  50]
% weights: [44.21, 44.21, 44.21  ...  15.1]
% allprobs: [0.0226, 0.0226, 0.0226  ...  0.0662]
% \end{lstlisting}

% \subsection{Example: Clustered sample}

% \begin{lstlisting}
% julia> clus1 = load_data("apiclus1");

% julia> dclus1 = SurveyDesign(clus1; weights = :pw,
%                 clusters=:dnum)
% SurveyDesign:
% data: 200 x 45 DataFrame
% strata: none
% cluster: dnum
%     [401, 401, 541  ...  802]
% popsize: [5968.3499, 5968.3499, 5968.3499  ...  2038.5001]
% sampsize: [135, 135, 135  ...  135]
% weights: [44.21, 44.21, 44.21  ...  15.1]
% allprobs: [0.0226, 0.0226, 0.0226  ...  0.0662]
% \end{lstlisting}

% \subsection{Example: Multistage sample}

% \begin{lstlisting}
% julia> apiclus2 = load_data("apiclus2")

% julia> SurveyDesign(apiclus2; clusters=[:dnum, :snum])
% Warning: As part of single-stage approximation, 
%             only the first stage cluster ID is retained.
% SurveyDesign:
% data: 126x46 DataFrame
% strata: none
% cluster: dnum
%     [15, 63, 83  ...  795]
% popsize: [40, 40, 40  ...  40]
% sampsize: [40, 40, 40  ...  40]
% weights: [1, 1, 1  ...  1]
% allprobs: [1.0, 1.0, 1.0  ...  1.0]
% \end{lstlisting}


\subsection{Example: Clustered and stratified}

\begin{lstlisting}
julia> nhanes = load_data("nhanes")

julia> SurveyDesign(nhanes; clusters=:SDMVPSU,
                    strata=:SDMVSTRA, weights=:WTMEC2YR)
SurveyDesign:
data: 8591 x 11 DataFrame
strata: SDMVSTRA
    [83, 84, 86  ...  81]
cluster: SDMVPSU
    [1, 1, 2  ...  2]
popsize: [244586.316, 43527.8366, 36124.9061  ...  19331.022]
sampsize: [3, 3, 3  ...  3]
weights: [81528.772, 14509.2789, 12041.6354  ...  6443.674]
allprobs: [0.0, 0.0001, 0.0001  ...  0.0002]
\end{lstlisting}

There is only 1 constructor for all kinds of surveys. Every survey is assumed to be a complex survey. If there is no stratification, we assume that everything is part of 1 strata. 

% \begin{lstlisting}
% if typeof(strata) <: Nothing
%     data.false_strata = repeat(["FALSE_STRATA"], nrow(data))
%     strata = :false_strata
% end
% \end{lstlisting}

% If there is no clustering, we assume that every element is a cluster. 

% \begin{lstlisting}
% if typeof(clusters) <: Nothing
%     data.false_cluster = 1:nrow(data)
%     cluster = :false_cluster
% end
% \end{lstlisting} %% No need to show this implementation. In the session, better ways were pointed out. 

\section{Estimation}

\begin{description}
    \item[Univariate]: mean, median, total, quantile, etc. For example, the average height of adult men. 
    \item[Multivaraite]: ratio, regression, etc. For example, the relationship between height and weight. 
\end{description}

\subsection{Univariate}
\begin{lstlisting}
julia> mean(:api99, survey_design)
1x1 DataFrame
    Row | mean
        | Float64
-----|--------
    1 | 624.685
julia> quantile(:api99, survey_design, 0.7)
1x1 DataFrame
    Row | 0.7th percentile 
        | Float64          
-----|-----------------
    1 |            708.0
\end{lstlisting}

\subsection{Multivariate}
\begin{lstlisting}
julia> glm(@formula(y ~ x), my_design, Normal(),

IdentityLink())

julia> ratio(:y, :x, my_design)
\end{lstlisting}


\section{Replicate weights}

The standard error of an estimator measures the average amount of variability or uncertainty in the estimated value. Standard errors are often provided alongside point estimates in various statistical packages, and these are suitable for simple random samples.

Estimate design based standard errors by simulation. 
    \begin{itemize}
        \item Construction:
            \begin{itemize}
                \item Replicate samples generated through resampling techniques (e.g., bootstrap, jackknife, BRR).
                \item Each replicate sample represents a plausible variation of the original sample.
                \item Standard error can be thought of as the variation if the sampling was done repeated. 
            \end{itemize}
        \item Usage:
            \begin{enumerate}
                \item Generate replicate weights using bootstrap, jackknife, BRR, etc. 
                \item Using each replicate weight, calculate the estimate. 
                \item Calculate the standard error using the new set of estimates. 
            \end{enumerate}
        \end{itemize}

\begin{lstlisting}
function variance(design::ReplicateDesign{BootstrapReplicates},
func::Function, ...)

function variance(design::ReplicateDesign{JackknifeReplicates},
    func::Function, ...)
\end{lstlisting}

\subsection{Bootstrapping}

For bootstrap replicate $r (r = 1, \dots, R)$, an SRS of $n_h - 1$ PSUs is selected with replacement from the $n_h$ sample PSUs in stratum $h$. $m_{hj}(r)$ represents the number of times PSU $j$ of stratum $h$ is selected in replicate $r$.

The adjusted weight $w_i'(r)$ for observation $i$ in replicate $r$ is calculated as:

\begin{equation}
    w_i'(r) = w_i(r) \times \frac{n_h}{n_h - 1} \times m_{hj}(r)
\end{equation}

Here, $w_i(r)$ denotes the initial weight for observation $i$ within replicate $r$, $n_h$ is the total number of observations in stratum $h$, and $m_{hj}(r)$ is a multiplier term specific to observation $i$ in PSU $j$ of stratum $h$ for replicate $r$.

\begin{lstlisting}
    julia> srs = SurveyDesign(apisrs; weights=:pw);
    
    julia> bsrs = bootweights(srs; replicates = 1000)
    ReplicateDesign{BootstrapReplicates}:
    data: 200x1045 DataFrame
    strata: none
    cluster: none
    popsize: [6194.0, 6194.0, 6194.0  ...  6194.0]
    sampsize: [200, 200, 200  ...  200]
    weights: [30.97, 30.97, 30.97  ...  30.97]
    allprobs: [0.0323, 0.0323, 0.0323  ...  0.0323]
    type: bootstrap
    replicates: 1000
\end{lstlisting}

$\hat{\theta}^*_r$ is the estimator of $\theta$, calculated the same way as $\hat{\theta}$ but using weights $w_i(r)$ instead of the original weights $w_i$. 

\begin{equation}
        \hat{V}_B(\hat{\theta}) = \dfrac{1}{R-1}\sum_{r=1}^{R} (\hat{\theta}^*_r - \hat{\theta})^2.
\end{equation}

\begin{lstlisting}
julia> mean(:api99, bsrs)
1x2 DataFrame
    Row | mean     SE      
        | Float64  Float64 
-----|-----------------
    1 | 624.685  9.84669
\end{lstlisting}

\subsection{Jackknife}

\begin{equation*}
    w_{i(hj)} = \begin{cases}
        w_i & i \notin h\\
    0 & i \in j_{h} \\
    \dfrac{n_h}{n_h - 1} w_i &  i \in h \text{ and } i \notin j_{h}
    \end{cases}
    \end{equation*} \cite{jackknifeLohr}


\begin{lstlisting}
julia> jsrs = jackknifeweights(srs)
ReplicateDesign{JackknifeReplicates}:
data: 200x245 DataFrame
strata: none
cluster: none
popsize: [6194.0, 6194.0, 6194.0  ...  6194.0]
sampsize: [200, 200, 200  ...  200]
weights: [30.97, 30.97, 30.97  ...  30.97]
allprobs: [0.0323, 0.0323, 0.0323  ...  0.0323]
type: jackknife
replicates: 200
\end{lstlisting}

$\hat{\theta}$ represents the estimator computed using the original weights, and $\hat{\theta_{(hj)}}$ represents the estimator computed from the replicate weights obtained when PSU $j$ from cluster $h$ is removed.

\begin{equation}
\hat{V}_{\text{JK}}(\hat{\theta}) = \sum_{h = 1}^H \dfrac{n_h - 1}{n_h}\sum_{j = 1}^{n_h}(\hat{\theta}_{(hj)} - \hat{\theta})^2
\end{equation}


% at appropriate place in your \TeX{} file or in bibliography file.


\input{bib.tex}

\end{document}

% Inspired by the International Journal of Computer Applications template
